<!DOCTYPE html ><html lang="en-US"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="shortcut icon" href="../icons/favicon.ico" /><link rel="stylesheet" href="../css/bulma.css" /><link rel="stylesheet" href="../css/font-awesome.min.css" /><link rel="stylesheet" href="../css/presentationStyle.css" /><link rel="stylesheet" href="../css/vs.min.css" /><script src="../scripts/jquery-3.5.1.min.js"></script><script src="../scripts/clipboard.min.js"></script><script src="../scripts/highlight.min.js"></script><script src="../scripts/presentationStyle.js"></script><title>Persistent collections</title><meta name="Title" content="Persistent collections" /><meta name="Help.Id" content="90045984-e6ce-4e13-b778-ec6a15ac7b01" /><meta name="Help.ContentType" content="Concepts" /><meta name="guid" content="90045984-e6ce-4e13-b778-ec6a15ac7b01" /><meta name="Description" content="A persistent data structure preserves its previous versions upon modifications. As such, they are easier to use in multi-threaded scenarios where modifications by one thread must not affect other threads' view of the data. The Wikipedia articlehttps://en." /><meta name="tocFile" content="../toc/Root.xml" /></head><body><div class="fixedLayout"><div id="Header" class="fixedHeader"><div class="pageHeader level mb-0 py-2 px-4"><div id="TitleContainer" class="level-left"><div class="level-item"><img src="../icons/Help.png" /></div><div id="DocumentationTitle" class="level-item">Podaga libraries</div></div><div id="LangFilterSearchContainer" class="level-right"><div class="level-item"><div class="dropdown is-hoverable"><div class="dropdown-trigger"><button class="button" aria-haspopup="true" aria-controls="dropdown-menu"><span id="CurrentLanguage"></span><span class="icon is-small"><i class="fa fa-angle-down" aria-hidden="true"></i></span></button></div><div class="dropdown-menu" role="menu"><div id="LanguageSelections" class="dropdown-content"><a class="dropdown-item languageFilterItem" data-languageId="cs">C#</a></div></div></div></div><div class="level-item"><form id="SearchForm" action="#" onsubmit="TransferToSearchPage(); return false;"><div class="field"><div class="control has-icons-left"><input id="SearchTerms" class="input" type="text" maxlength="200" placeholder="Search" /><span class="icon is-small is-left"><i class="fa fa-search"></i></span><button id="SearchButton" type="submit" class="is-hidden"></button></div></div></form></div></div></div></div><div class="fixedContent"><nav class="breadcrumb my-1 px-2 border-bottom" role="navigation"><ul id="TopicBreadcrumbs" /></nav><div id="ContentContainer" class="columns pl-5 pr-5 fixedContent"><div id="ShowHideTOCColumn" class="column is-hidden-tablet"><a id="ShowHideTOC">Show/Hide TOC</a></div><div id="TOCColumn" class="column is-hidden-mobile"><nav class="toc"><ul id="TableOfContents" class="toc-menu" /></nav></div><div id="Resizer" class="is-hidden"></div><div id="TopicContent" class="column content is-7"><h1>Persistent collections</h1><div><p>
        A persistent data structure preserves its previous versions upon modifications.  As such, they are easier to use in multi-threaded
        scenarios where modifications by one thread must not affect other threads' view of the data.  The
        <a href="https://en.wikipedia.org/wiki/Persistent_data_structure" target="_blank" rel="noopener noreferrer">Wikipedia article</a>
        provides extensive background with further references.
      </p><p>
        This library provides two such data structures: a dense vector and an augmentable tree framework.  Of the two, the latter is much more
        feature-complete.
      </p></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Introduction</h2><div id="IDDABSection"><p>
          Because most developers are used to the convenience of ordinary mutable data structures (e.g., <span class="code">List&lt;T&gt;</span>),
          this library introduces the concept of <em>forking</em>.  The collections behave as ordinary mutable collections,
          but forking creates an independent "copy" of the original collection such that modifications to one are invisible to the other.
        </p><article class="message is-info"><div class="message-header"><p><span class="icon"><i class="fa fa-info-circle"></i></span>  Note</p></div><div class="message-body"><p>
            Forking is <em>cheap</em>: only a fresh collection object is created whereas the actual data is copied lazily upon
            mdification of the collection.  In operating systems, this is also known as <em>copy-on-write</em> semantics which
            enables space-efficient sharing of memory pages.
          </p></div></article><p>
          The collections consint internally of nodes which always carry a <em>transient tag</em> which is a unique 64-bit integer.
          The transient tag is also attached to the collection itself so that it knows which nodes must be physically copied before their
          contents is modified.  Generation of transient tags is handled by methods on <a href="c780e5da-0896-b393-98db-24688d00c63a.htm">TransientSource</a>
          class.
        </p><blockquote>
          Transient tag provides a unique identity for the node and most papers use <span class="code">object</span> instance for the transient tag.
          In .NET however, reference assignment invokes <span class="code">CORINFO_HELP_ASSIGN_REF</span> method which ensures proper GC tracking
          and is thus slower than using <span class="code">ulong</span>.
        </blockquote><p>
          The library is delivered with a test suite that tests correctness using all combinations of predefined add/remove patterns (<a href="848547e5-5984-fa18-885e-55c1e5392e55.htm">PermutationGenerators</a>).
        </p></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Vector</h2><div id="IDEABSection"><p>
          Vector implementation is based on the following
          <a href="https://dl.acm.org/doi/pdf/10.1145/3110260" target="_blank" rel="noopener noreferrer">paper</a></p><blockquote>
          Juan Pedro Bolívar Puente. 2017. Persistence for the Masses: RRB-Vectors in a Systems Language. Proc. ACM
          Program. Lang. 1, ICFP, Article 16 (September 2017), 28 pages.
        </blockquote><p><a href="8a64fa5c-056d-532e-2464-2c6a696aaa5d.htm">Vector<span id="LST1841A9A1_0" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'"></span>T<span id="LST1841A9A1_1" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;"></span></a> is straightforward
          to instantiate and use.  <a href="fd0e07dd-a4bc-070b-6425-9042dd92a293.htm">VectorParameters</a>
          allows adjustment of internal and external node sizes and most papers use value of 5 for both shift factors (i.e., a node size of 32).
          Because nodes are copied during modifications, it might be advantageous to choose a smaller size for external nodes if the vector's
          element type is a large struct.
        </p></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Tree framework</h2><div id="IDFABSection"><p>
          The implementation is based on the following
          <a href="https://doi.org/10.1145/3512769" target="_blank" rel="noopener noreferrer">paper</a></p><blockquote>
          Guy Blelloch, Daniel Ferizovic, and Yihan Sun. 2022. Joinable Parallel Balanced Binary Trees. ACM Trans.
          Parallel Comput. 9, 2, Article 7 (April 2022), 41 pages.
        </blockquote><p>
          The tree framework is more involved to use; see the walkthrough section.  It provides the following fetures
        </p><ul><li><p>AVL and weight-balanced trees.</p></li><li><p>On-demand persistence through forking.</p></li><li><p>
              User-provided monoidal augmentations (useful for implementing, e.g., interval trees).  Indexing augmentation, i.e.,
              logarithmic element access by index in sorted order is provided out of the box.
            </p></li><li><p>
              Adapters to standard interfaces:
              <a href="https://learn.microsoft.com/dotnet/api/system.collections.generic.icollection-1" target="_blank" rel="noopener noreferrer">ICollection<span id="LST1841A9A1_2" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'"></span>T<span id="LST1841A9A1_3" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;"></span></a>,
              <a href="https://learn.microsoft.com/dotnet/api/system.collections.generic.ireadonlylist-1" target="_blank" rel="noopener noreferrer">IReadOnlyList<span id="LST1841A9A1_4" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'"></span>T<span id="LST1841A9A1_5" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;"></span></a>,
              <a href="https://learn.microsoft.com/dotnet/api/system.collections.generic.iset-1" target="_blank" rel="noopener noreferrer">ISet<span id="LST1841A9A1_6" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'"></span>T<span id="LST1841A9A1_7" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;"></span></a>,
              <a href="https://learn.microsoft.com/dotnet/api/system.collections.generic.idictionary-2" target="_blank" rel="noopener noreferrer">IDictionary<span id="LST1841A9A1_8" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'"></span>TKey, TValue<span id="LST1841A9A1_9" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;"></span></a>.
            </p></li><li><p>
              The adapters are "views" over the same tree and are cheap to construct.  In particular, they allow to convert a "dictionary view"
              of the tree to a "set view", thus allowing for efficient set-operations over dictionaries.
            </p></li><li><p><a href="2af394ed-1c09-ca21-de7b-b8ae11c1844b.htm">TreeIterator<span id="LST1841A9A1_10" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'"></span>TValue<span id="LST1841A9A1_11" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;"></span></a>
              allows position-based, non-recursive iteration over tree elements in sorted order.
            </p></li><li><p>
              Traits-based design through static abstract interface methods that makes it easier to reuse components and, hopefully,
              allows for better JIT optimizations (inlining).
            </p></li><li><p>
              Transparent: most algorithms are implemented as extension methods over <a href="93d88823-e7b4-0812-26cb-5aa28c19e71c.htm">JoinableTreeNode<span id="LST1841A9A1_12" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'"></span>TValue<span id="LST1841A9A1_13" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;"></span></a>.
            </p></li></ul></div></div><div id="InThisArticleColumn" class="column is-hidden-mobile"><nav class="menu sticky is-hidden"><p class="menu-label"><strong>In This Article</strong></p><ul id="InThisArticleMenu" class="menu-list"><li><a class="quickLink">Introduction</a></li><li><a class="quickLink">Vector</a></li><li><a class="quickLink">Tree framework</a></li></ul></nav></div></div></div></div><script>$(function(){
SetDefaultLanguage("cs");
LoadTocFile(null, null);
InitializeQuickLinks();

$(".toggleSection" ).click(function () {
    SectionExpandCollapse(this);
});

$(".toggleSection").keypress(function () {
    SectionExpandCollapseCheckKey(this, event)
});
});</script></body></html>